--자바에서 CallableStatement test
DROP TABLE EMP1;
CREATE TABLE EMP1
AS
SELECT EMPLOYEE_ID,FIRST_NAME,DEPARTMENT_ID,SALARY FROM EMPLOYEES;

SELECT * FROM EMP1 ORDER BY DEPARTMENT_ID;

--부서별로 10이면 10% 인상,20이면 20%인상 나머지는 동결하는 SQL문을 프로시저로 작성
CREATE OR REPLACE PROCEDURE EMP1_PROCEDURE(
    VDEPARTMENT_NO IN EMP1.DEPARTMENT_ID%TYPE,
    VINCREMENT_SALARY NUMBER);
    
BEGIN
    UPDATE EMP1 SET SALARY = SALARY*VINCREMENT_SALARY
    WHERE DEPARTMENT_ID = VDEPARTMENT_NO;
    COMMIT;
END;
/


CREATE OR REPLACE PROCEDURE BOOKS_PROCEDURE(
    VID IN BOOKS.ID%TYPE, VPRICE IN BOOKS.PRICE%TYPE,VMESSAGE OUT VARCHAR2)
IS
    VBOOKS_RT BOOKS%ROWTYPE;
BEGIN
    UPDATE BOOKS
        SET PRICE = PRICE + VPRICE WHERE ID = VID;
        COMMIT;
        SELECT * INTO VBOOKS_RT FROM BOOKS WHERE ID = VID;
        VMESSAGE := VBOOKS_RT.ID||' 번호의 인상금액은 ' || VPRICE ||'이고 총 금액은'|| VBOOKS_RT.PRICE ||'입니다';
END;
/
VARIABLE MESSAGE VARCHAR2(100);
EXECUTE EMP1_PROCEDURE (1,10000,:MESSAGE);
SELECT * FROM EMP1 ORDER BY DEPARTMENT_ID;
-------------------------------------------------
-- 자바에서 CallableStatement test
DROP TABLE EMP1; 
CREATE TABLE EMP1
AS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY FROM EMPLOYEES;

SELECT * FROM EMP1 ORDER BY DEPARTMENT_ID;

--부서별 번호와 인상율 입력하면 해당되는 부서만 인상률로 적용하는  SQL문을 프로시저로 작성 
CREATE OR REPLACE PROCEDURE  BOOKS_PROCEDURE(
    VID IN BOOKS.ID%TYPE, VPRICE IN BOOKS.PRICE%TYPE , VMESSAGE OUT VARCHAR2)
IS
    VBOOKS_RT BOOKS%ROWTYPE; 
BEGIN
    UPDATE BOOKS 
    SET PRICE = PRICE + VPRICE WHERE ID = VID; 
    COMMIT;
    SELECT * INTO VBOOKS_RT FROM BOOKS WHERE ID = VID; 
    VMESSAGE := VBOOKS_RT.ID||' 번호의 인상금액은 '|| VPRICE ||'이고 총 금액은'|| VBOOKS_RT.PRICE ||'입니다'; 
    DBMS_OUTPUT.PUT_LINE(VMESSAGE); 
END;
/
--------------------------------------------------------------
CREATE OR REPLACE FUNCTION BOOKS_FUNCTION (
    VID IN BOOKS.ID%TYPE) 
RETURN VARCHAR2 IS
    VBOOKS_RT BOOKS%ROWTYPE;
    VMESSAGE VARCHAR2(100);
BEGIN
    --UPDATE BOOKS
    --SET PRICE = PRICE + VPRICE
    --WHERE ID = VID;
    SELECT * INTO VBOOKS_RT FROM BOOKS WHERE ID = VID;
    VMESSAGE := VBOOKS_RT.ID || ' 번호의 총 금액은 ' || VBOOKS_RT.PRICE || '입니다';
    RETURN VMESSAGE;
END;
/
SELECT BOOKS_FUNCTION(1) AS "RESULT" FROM DUAL;

CREATE OR REPLACE TRIGGER STU_TRIGGER
BEFORE INSERT ON STU01
FOR EACH ROW
BEGIN
    :NEW.SUM := :NEW.KOR + :NEW.ENG + :NEW.MATH;
    :NEW.AVG := ROUND((:NEW.KOR + :NEW.ENG + :NEW.MATH) / 3, 1);
END;
/
--update 시 합, 평균이 같이 변하는 트리거 생성
CREATE OR REPLACE TRIGGER STU_TRIGGER2
BEFORE UPDATE ON STU01
FOR EACH ROW
BEGIN
    :NEW.SUM := :NEW.KOR + :NEW.ENG + :NEW.MATH;
    :NEW.AVG := ROUND((:NEW.KOR + :NEW.ENG + :NEW.MATH) / 3, 1);
END;

VARIABLE MESSAGE VARCHAR2(200);
EXECUTE BOOKS_PROCEDURE(1, 10000, :MESSAGE);

SELECT * FROM BOOKS;
-----------------------------------
CREATE OR REPLACE PROCEDURE  BOOKS_PROCEDURE(
    VID IN BOOKS.ID%TYPE, VPRICE IN BOOKS.PRICE%TYPE , VMESSAGE OUT VARCHAR2)
IS
    VBOOKS_RT BOOKS%ROWTYPE; 
BEGIN
    UPDATE BOOKS 
    SET PRICE = PRICE + VPRICE WHERE ID = VID; 
    COMMIT;
    SELECT * INTO VBOOKS_RT FROM BOOKS WHERE ID = VID; 
    VMESSAGE := VBOOKS_RT.ID||' 번호의 인상금액은 '|| VPRICE ||'이고 총 금액은'|| VBOOKS_RT.PRICE ||'입니다'; 
    DBMS_OUTPUT.PUT_LINE(VMESSAGE); 
END;
/
DROP TABLE EMP1; 
CREATE TABLE EMP1
AS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY FROM EMPLOYEES;

SELECT * FROM EMP1 ORDER BY DEPARTMENT_ID;

--부서별 번호와 인상율 입력하면 해당되는 부서만 인상률로 적용하는  SQL문을 프로시저로 작성 
CREATE OR REPLACE PROCEDURE  BOOKS_PROCEDURE(
    VID IN BOOKS.ID%TYPE, VPRICE IN BOOKS.PRICE%TYPE , VMESSAGE OUT VARCHAR2)
IS
    VBOOKS_RT BOOKS%ROWTYPE; 
BEGIN
    UPDATE BOOKS 
    SET PRICE = PRICE + VPRICE WHERE ID = VID; 
    COMMIT;
    SELECT * INTO VBOOKS_RT FROM BOOKS WHERE ID = VID; 
    VMESSAGE := VBOOKS_RT.ID||' 번호의 인상금액은 '|| VPRICE ||'이고 총 금액은'|| VBOOKS_RT.PRICE ||'입니다'; 
    DBMS_OUTPUT.PUT_LINE(VMESSAGE); 
END;
/
VARIABLE MESSAGE VARCHAR2(200);
EXECUTE BOOKS_PROCEDURE(1, 10000, :MESSAGE);

SELECT * FROM BOOKS;
-------------------
-- employees
SELECT * FROM EMPLOYEES;
desc employees;

--books
DROP TABLE BOOKS;
CREATE TABLE books (
       id number(4), 
        title varchar2(50), 
        publisher varchar2(30), 
        year varchar2(10), 
        price number(6) 
);
ALTER TABLE BOOKS ADD CONSTRAINT BOOKS_ID_PK PRIMARY KEY(ID);

CREATE SEQUENCE BOOKS_ID_SEQ
START WITH 1
INCREMENT BY 1;

INSERT INTO books  VALUES (bookS_id_seq.nextval, 'Operating System Concepts', 'Wiley', '2003',30700);
INSERT INTO books  VALUES (bookS_id_seq.nextval, 'Head First PHP and MYSQL', 'OReilly', '2009', 58000);
INSERT INTO books  VALUES (bookS_id_seq.nextval, 'C Programming Language', 'Prentice-Hall', '1989', 35000);
INSERT INTO books  VALUES (bookS_id_seq.nextval, 'Head First SQL', 'OReilly', '2007', 43000);
commit;

SELECT * FROM BOOKS;

DESC BOOKS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'BOOKS';

DELETE FROM BOOKS WHERE ID = 5;
ROLLBACK;
UPDATE BOOKS SET TITLE = 'KKK', PUBLISHER = 'JAVA',YEAR ='2024',PRICE=33000 WHERE ID = 10;
------------------------------------