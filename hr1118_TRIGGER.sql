-- TRIGGER 테스팅
-- EMP01 생성하고 트리거를 생성한다(입력이 될때마다 입력값을 출력해줌)
DROP TABLE EMP01;
CREATE TABLE EMP01(
        EMPNO NUMBER(4) PRIMARY KEY,
        ENAME VARCHAR2(20),
        JOB VARCHAR2(50)
);

CREATE OR REPLACE TRIGGER EMP01_TRIGGER
    AFTER INSERT ON EMP01
    FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO || ', ' || :NEW.ENAME|| '신입사원이 입사했습니다');
END;
/

INSERT INTO EMP01 VALUES((SELECT NVL(MAX(EMPNO),0)+1 FROM EMP01),DBMS_RANDOM.STRING('U',4),'IT_DEV');

CREATE TABLE SAL01(
    SALNO NUMBER(4),
    SAL NUMBER,
    EMPNO NUMBER(4)
    );
ALTER TABLE SAL01 ADD CONSTRAINTS SAL01_SALNO_PK PRIMARY KEY(SALNO);
ALTER TABLE SAL01 ADD CONSTRAINTS SAL01_EMPNO_FK FOREIGN KEY(EMPNO) REFERENCES EMP01(EMPNO);

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'SAL01';

--시퀀스 생성
CREATE SEQUENCE SAL01_SEQ
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 1000000
    NOCYCLE
    CACHE 2;
    
CREATE OR REPLACE TRIGGER EMP01_TRIGGER2
    AFTER INSERT ON EMP01
    FOR EACH ROW
BEGIN
    INSERT INTO SAL01 VALUES(SAL01_SEQ.NEXTVAL,100000,:NEW.EMPNO);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO || '번호 사원이 SALO1 잘 들어왔습니다');
END;
/
--EMP01 에서 사원의 정보를 제거했을때 SAL01 해당되는 사원의 정보가 삭제되도록프로그램 하시오
CREATE OR REPLACE TRIGGER EMP01_TRIGGER3
    AFTER DELETE ON EMP01
    FOR EACH ROW
BEGIN
    DELETE FROM SAL01 WHERE EMPNO = :OLD.EMPNO;
    DBMS_OUTPUT.PUT_LINE(:OLD.EMPNO || '번호가 SAL01에서 삭제되었습니다.');
END;
/
DELETE FROM EMP01 WHERE EMPNO = 4;
SELECT * FROM EMP01;
SELECT * FROM SAL01;

-----------가구 재고 프로그램------------
DROP TABLE PRODUCT;
DROP TABLE RECEIVING;
DROP TRIGGER RECEIVING_TRIGGER01;

CREATE TABLE PRODUCT(
    CODE CHAR(6),
    NAME  VARCHAR(12) NOT NULL,
    COMPANY VARCHAR(12),
    PRICE NUMBER(8),
    STOCK NUMBER DEFAULT 0
    );
ALTER TABLE PRODUCT ADD CONSTRAINTS PRODUCT_CODE_PK PRIMARY KEY(CODE);


CREATE TABLE RECEIVING(
    NO NUMBER(6),
    CODE CHAR(6),
    RDATE DATE,
    QTY NUMBER(6),
    PRICE NUMBER(8),
    AMOUNT NUMBER(8)
    );
ALTER TABLE RECEIVING ADD CONSTRAINTS RECEVING_NO_PK PRIMARY KEY(NO);
ALTER TABLE RECEIVING ADD CONSTRAINTS RECEVING_CODE_PK FOREIGN KEY(CODE) REFERENCES PRODUCT(CODE);

INSERT INTO PRODUCT(CODE, NAME, COMPANY, PRICE)
    VALUES('A00001','세탁기', 'LG', 1500000);
INSERT INTO PRODUCT(CODE, NAME, COMPANY,PRICE)
    VALUES('A00002','컴퓨터', 'LG', 1000000);
INSERT INTO PRODUCT(CODE, NAME, COMPANY,PRICE)
    VALUES('A00003','냉장고', '삼성', 4500000);
SELECT * FROM PRODUCT;


CREATE OR REPLACE TRIGGER RECEIVING_TRIGGER01
    AFTER INSERT ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK + :NEW.QTY
    WHERE CODE = :NEW.CODE;
END;
/

INSERT INTO RECEIVING(NO,CODE, QTY, PRICE, AMOUNT)
VALUES((SELECT NVL(MAX(NO),0)+1 FROM RECEIVING), 'A00002', 10, 680000, 780000);  

SELECT * FROM PRODUCT;

--갱신트리거 만들기 입고수량을 30=>10진행을 했는데 마지막 10개를 5개로 수정하면, PRODUCT 재고를 5개
--줄이는 트리거를 만들것
CREATE OR REPLACE TRIGGER RECEVING_TRIGGER
        AFTER UPDATE ON RECEIVING 
        FOR EACH ROW
BEGIN
        UPDATE PRODUCT SET STOCK = STOCK + (-:OLD.QTY + :NEW.QTY)
        WHERE CODE = :NEW.CODE;
END;
/

UPDATE RECEIVING SET QTY = 8,PRICE = 100000,AMOUNT = 100000 WHERE CODE = 'A00002';
ROLLBACK;
SELECT * FROM PRODUCT;

--삭제트리거(입고부분에서 삭제가 되면 재고부분에서 삭제된 수량을 빼준다)
CREATE  OR REPLACE TRIGGER RECEIVING_DEL_TRIGGER
        AFTER DELETE ON RECEIVING
        FOR EACH ROW
BEGIN
        UPDATE PRODUCT SET STOCK = STOCK - :OLD.QTY
        WHERE CODE = :OLD.CODE;
END;
/
SELECT * FROM RECEIVING;
SELECT * FROM PRODUCT;

DELETE FROM RECEIVING WHERE NO = 3;

--FUNCTION 부서번호를 입력하면 부서명을 리턴해주는 함수를 만드시오
--부서번호가 없는 번호라면 '부서번호없음'을 리턴하시오
CREATE OR REPLACE FUNCTION GET_DEPARTMENT_NAME_FUNC(VDEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE) RETURN VARCHAR2
IS
        VDEPARTMENT_NAME VARCHAR2(100);
        VCOUNT NUMBER := 0;
BEGIN
        --해당 부서의 카운트를 체크
         SELECT COUNT(*) FROM EMPLOYEES WHERE DEPARTMENT_ID =100;
        
        IF (VCOUNT = 0) THEN
                VDEPARTMENT_NAME := '해당부서없음';
        ELSE
                SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS
                WHERE DEPARTMENT_ID = VDEPARTMENT_ID
        END IF;
        RETURN VDEPARTMENT_NAME;
END;
/
      
SELECT FIRST_NAME,SALARY, DEPARTMENT_ID, GET_DEPARTMENT_NAME_FUNC(DEPARTMENT_ID) as
FROM EMPLOYEES WHERE fisrt_NAME = 'Steven';

VARIABLE VNAME VARCHAR2;
EXECUTE :VNAME := GET_DEPARTMENT_NAME_FUNC(90);
PRINT VNAME;